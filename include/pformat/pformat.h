#include <algorithm>
#include <array>
#include <cassert>
#include <cstring>
#include <iostream>
#include <numeric>
#include <tuple>
#include <type_traits>
#include <vector>

#include "fixed_string.h"
#include "parser.h"
#include "placement.h"

namespace pformat {

/**
 * An instance of a instrancation of this type
 * is returned from the _fmt literal.
 *
 * It is advised to store the result in an 'auto' variable
 * or to not store it at all.
 */
template <typename parse_result_t>
class log_config {
    parse_result_t parse_result;

    inline constexpr auto get_parameter_count() const {
        return parse_result.get_parameter_count();
    }

   public:
    explicit constexpr log_config(parse_result_t const &result_)
        : parse_result(result_) {}
    /**
     * returns an upper bound on the string size
     * generated by a format call with the given set of parameters
     * including the trailing zero.
     */
    template <typename... args_t>
    size_t string_size_bound(args_t &&... args) const {
        constexpr bool parameter_count_match =
            parse_result_t::get_parameter_count() == sizeof...(args);
        constexpr auto placeable = placement::test_placements<args_t...>();
        static_assert(parse_result_t::get_parameter_count() == sizeof...(args));
        if constexpr (!parameter_count_match || !placeable) {
            return 0;
        } else {
            auto t = std::forward_as_tuple(std::forward<args_t>(args)...);
            size_t size{};
            parse_result.visit([&size](auto fe) { size += fe.size(); },
                               [&t, &size](auto pe) {
                                   using placement::placement_size;
                                   size +=
                                       placement_size(std::get<pe.index>(t));
                               });
            return size + 1;
        }
    }

    template <typename... args_t>
    std::string operator()(args_t &&... args) const {
        return format(std::forward<args_t>(args)...);
    }

    /**
     * Use the format definiton and the arguments to
     * create a formatted string.
     */
    template <typename... args_t>
    std::string format(args_t &&... args) const {
        constexpr bool parameter_count_match =
            parse_result_t::get_parameter_count() == sizeof...(args);
        constexpr auto placeable = placement::test_placements<args_t...>();
        static_assert(
            parameter_count_match,
            "Number of format arguments does not match format string");
        if constexpr (!parameter_count_match || !placeable) {
            // we will already have static asserted when getting here, but
            // to ensure a readable error message, we cut out the rest of the
            // processing
            return {};
        } else {
            const auto s = string_size_bound(std::forward<args_t>(args)...);
            std::string str_result;
            str_result.resize(s);  // reserve sufficient space for the output
            auto t = std::forward_as_tuple(std::forward<args_t>(args)...);
            char *buf = str_result.data();

            parse_result_t::visit(
                [this, &buf](auto fe) {
                    using placement::unsafe_place;
                    buf = unsafe_place(
                        buf, parse_result.str().data() + fe.start, fe.size());
                },
                [this, &t, &buf](auto pe) {
                    using placement::unsafe_place;
                    auto const &arg = std::get<pe.index>(t);
                    buf = unsafe_place(buf, arg);
                });
            *buf = 0;
            str_result.resize(buf - str_result.data());
            return str_result;
        }
    }

    /**
     * Use the format definiton and the arguments to
     * create a formatted output and store it in the provided buffer.
     *
     * The buffer is expected to have at least a size of
     * string_size_bound(...) many bytes.
     */
    template <typename... args_t>
    char *format_to(char *buf, args_t &&... args) const {
        constexpr bool parameter_count_match =
            parse_result_t::get_parameter_count() == sizeof...(args);
        static_assert(
            parameter_count_match,
            "Number of format parameters doesn't match to format string");
        if constexpr (!parameter_count_match) {
            // we will already have static asserted when getting here, but
            // to ensure a readable error message, we cut out the rest of
            // the processing
            return {};
        } else {
            constexpr auto placeable = placement::test_placements<args_t...>();
            if constexpr (!placeable) {
                // we will already have static asserted when getting here.
                return {};
            } else {
                auto t = std::forward_as_tuple(std::forward<args_t>(args)...);

                parse_result_t::visit(
                    [this, &buf](auto fe) {
                        using placement::unsafe_place;
                        buf = unsafe_place(buf,
                                           parse_result.str().data() + fe.start,
                                           fe.size());
                    },
                    [&buf, &t](auto pe) {
                        using placement::unsafe_place;
                        auto const &arg = std::get<pe.index>(t);
                        buf = unsafe_place(buf, arg);
                    });
                *buf = 0;
                return buf;
            }
        }
    }

    // return true if a format string is valid.
    // true for all log config objects returned by _fmt.
    constexpr bool ok() const noexcept {
        return parse_result.is_valid_format_string();
    }
};  // namespace pformat

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-string-literal-operator-template"
#endif

namespace internal {
/*
 * Literal to crete a log config object. The validity of the log config
 * object is not statically or runtime checked, but can be validated with
 * ok().
 */
template <typename char_t, char_t... charpack>
constexpr auto operator""_unchecked_fmt() noexcept {
    static_assert(std::is_same<char_t, char>::value, "Only char is supported");
    auto parse_result = internal::parse_format<charpack...>();
    return log_config(parse_result);
}

static_assert(""_unchecked_fmt.ok());
static_assert("foo"_unchecked_fmt.ok());
static_assert("foo {}"_unchecked_fmt.ok());
static_assert(!"foo {a}"_unchecked_fmt.ok());
static_assert("foo {} bar {}"_unchecked_fmt.ok());
static_assert(!"foo {{"_unchecked_fmt.ok());
static_assert("foo }}"_unchecked_fmt.ok());
static_assert(!"foo {{}}"_unchecked_fmt.ok());
static_assert("foo }}"_unchecked_fmt.ok());
static_assert(!"foo {"_unchecked_fmt.ok());
static_assert(!"foo {{}"_unchecked_fmt.ok());

}  // namespace internal

/**
 * Literal to create log config object.
 *
 * It is statically asserted that the log config object is valid
 */
template <typename char_t, char_t... charpack>
constexpr auto operator""_fmt() noexcept {
    static_assert(std::is_same<char_t, char>::value, "Only char is supported");
    auto parse_result = internal::parse_format<charpack...>();
    static_assert(parse_result.is_valid_format_string(),
                  "Format string is not valid");
    return log_config(parse_result);
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

}  // namespace pformat