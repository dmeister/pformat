#include <algorithm>
#include <array>
#include <cassert>
#include <cstring>
#include <iostream>
#include <numeric>
#include <tuple>
#include <type_traits>
#include <vector>

#include "fixed_string.h"
#include "parser.h"
#include "placement.h"

namespace pformat {

/**
 * An instance of a instrancation of this type
 * is returned from the _fmt literal.
 *
 * It is advised to store the result in an 'auto' variable
 * or to not store it at all.
 */
template <typename parse_result_t>
class log_config {
    parse_result_t parse_result;

    struct string_size_visitor {
        uint64_t size = 0;

        template <typename element_t>
        inline void visit_element(element_t const &e) noexcept {
            size += e.size();
        }

        template <typename parameter_t, typename arg_t>
        inline void visit_parameter(parameter_t const &, arg_t arg) noexcept {
            using placement::placement_size;
            size += placement_size(arg);
        }
    };

    inline constexpr auto get_parameter_count() const {
        return parse_result.get_parameter_count();
    }

    struct format_visitor {
        char *start_buf;
        char *buf;

        size_t size() const noexcept { return buf - start_buf; }

        inline format_visitor(char *buf_) : start_buf(buf_), buf(buf_) {}

        template <typename element_t>
        inline void visit_element(element_t const &e) {
            using placement::unsafe_place;
            buf = unsafe_place(buf, e.c_str(), e.size());
        }

        template <typename parameter_t, typename arg_t>
        inline void visit_parameter(parameter_t const &, arg_t &&arg) {
            using placement::unsafe_place;
            buf = unsafe_place(buf, std::forward<arg_t>(arg));
        }
    };

   public:
    explicit constexpr log_config(parse_result_t const &result_)
        : parse_result(result_) {}
    /**
     * returns an upper bound on the string size
     * generated by a format call with the given set of parameters
     * including the trailing zero.
     */
    template <typename... args_t>
    size_t string_size_bound(args_t &&... args) const {
        constexpr bool parameter_count_match =
            parse_result_t::get_parameter_count() == sizeof...(args);
        constexpr auto placeable = placement::test_placements<args_t...>();
        static_assert(parse_result_t::get_parameter_count() == sizeof...(args));
        if constexpr (!parameter_count_match || !placeable) {
            return 0;
        } else {
            string_size_visitor v;
            auto t = std::forward_as_tuple(std::forward<args_t>(args)...);
            parse_result.visit_with_tuple(v, std::move(t));
            return v.size + 1;
        }
    }

    template <typename... args_t>
    std::string operator()(args_t &&... args) const {
        return format(std::forward<args_t>(args)...);
    }

    /**
     * Use the format definiton and the arguments to
     * create a formatted string.
     */
    template <typename... args_t>
    std::string format(args_t &&... args) const {
        constexpr bool parameter_count_match =
            parse_result_t::get_parameter_count() == sizeof...(args);
        constexpr auto placeable = placement::test_placements<args_t...>();
        static_assert(
            parameter_count_match,
            "Number of format arguments does not match format string");
        if constexpr (!parameter_count_match || !placeable) {
            // we will already have static asserted when getting here, but
            // to ensure a readable error message, we cut out the rest of the
            // processing
            return {};
        } else {
            const auto s = string_size_bound(std::forward<args_t>(args)...);
            std::string str_result;
            str_result.resize(s);  // reserve sufficient space for the output
            format_visitor v(str_result.data());
            auto t = std::forward_as_tuple(std::forward<args_t>(args)...);
            parse_result_t::visit_with_tuple(v, t);
            *v.buf = 0;
            str_result.resize(v.size());
            return str_result;
        }
    }

    /**
     * Use the format definiton and the arguments to
     * create a formatted output and store it in the provided buffer.
     *
     * The buffer is expected to have at least a size of
     * string_size_bound(...) many bytes.
     */
    template <typename... args_t>
    char *format_to(char *buf, args_t &&... args) const {
        constexpr bool parameter_count_match =
            parse_result_t::get_parameter_count() == sizeof...(args);
        static_assert(
            parameter_count_match,
            "Number of format parameters doens't match to format string");
        if constexpr (!parameter_count_match) {
            // we will already have static asserted when getting here, but
            // to ensure a readable error message, we cut out the rest of
            // the processing
            return {};
        } else {
            constexpr auto placeable = placement::test_placements<args_t...>();
            if constexpr (!placeable) {
                // we will already have static asserted when getting here.
                return {};
            } else {
                format_visitor v(buf);
                auto t = std::forward_as_tuple(std::forward<args_t>(args)...);
                parse_result_t::visit_with_tuple(v, t);
                return v.buf;
            }
        }
    }

    // return true if a format string is valid.
    // true for all log config objects returned by _fmt.
    constexpr bool ok() const noexcept {
        return parse_result.is_valid_format_string();
    }
};  // namespace pformat

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-string-literal-operator-template"
#endif

namespace internal {
/*
 * Literal to crete a log config object. The validity of the log config
 * object is not statically or runtime checked, but can be validated with
 * ok().
 */
template <typename char_t, char_t... charpack>
constexpr auto operator""_unchecked_fmt() noexcept {
    static_assert(std::is_same<char_t, char>::value, "Only char is supported");
    auto parse_result = internal::parse_format<charpack...>();
    return log_config(parse_result);
}

static_assert(""_unchecked_fmt.ok());
static_assert("foo"_unchecked_fmt.ok());
static_assert("foo {}"_unchecked_fmt.ok());
static_assert(!"foo {a}"_unchecked_fmt.ok());
static_assert("foo {} bar {}"_unchecked_fmt.ok());
static_assert("foo {{"_unchecked_fmt.ok());
static_assert("foo }}"_unchecked_fmt.ok());
static_assert("foo {{}}"_unchecked_fmt.ok());
static_assert("foo }}"_unchecked_fmt.ok());
static_assert(!"foo {"_unchecked_fmt.ok());
static_assert(!"foo {{}"_unchecked_fmt.ok());

}  // namespace internal

/**
 * Literal to create log config object.
 *
 * It is statically asserted that the log config object is valid
 */
template <typename char_t, char_t... charpack>
constexpr auto operator""_fmt() noexcept {
    static_assert(std::is_same<char_t, char>::value, "Only char is supported");
    auto parse_result = internal::parse_format<charpack...>();
    static_assert(parse_result.is_valid_format_string(),
                  "Format string is not valid");
    return log_config(parse_result);
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

}  // namespace pformat