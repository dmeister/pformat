#include <cassert>

#include "fixed_string.h"
#include "parser.h"
#include "placement.h"

namespace pformat {

/**
 * An instance of a instrancation of this type
 * is returned from the _fmt literal.
 *
 * It is advised to store the result in an 'auto' variable
 * or to not store it at all.
 */
template <typename parse_result_t, bool valid, size_t pc>
class log_config {
    parse_result_t parse_result;

   public:
    explicit constexpr log_config(parse_result_t const &result_)
        : parse_result(result_) {}
    /**
     * returns an upper bound on the string size
     * generated by a format call with the given set of parameters
     * including the trailing zero.
     */
    template <typename... args_t>
    std::size_t string_size_bound(args_t &&... args) const {
        constexpr bool parameter_count_match = pc == sizeof...(args);
        constexpr auto placeable = placement::test_placements<args_t...>();
        static_assert(pc == sizeof...(args));
        if constexpr (!parameter_count_match || !placeable) {
            return 0;
        } else {
            std::size_t size{};
            parse_result.visit([&size](auto &&args) {
                                   using placement::placement_size;
                                   size += placement_size(args);
                               },
                               std::forward<args_t>(args)...);
            return size + 1;
        }
    }

    template <typename... args_t>
    std::string operator()(args_t &&... args) const {
        return format(std::forward<args_t>(args)...);
    }

    /**
     * Use the format definiton and the arguments to
     * create a formatted string.
     */
    template <typename... args_t>
    std::string format(args_t &&... args) const {
        constexpr bool parameter_count_match = pc == sizeof...(args);
        constexpr auto placeable = placement::test_placements<args_t...>();
        static_assert(
            parameter_count_match,
            "Number of format arguments does not match format string");
        if constexpr (!parameter_count_match || !placeable) {
            // we will already have static asserted when getting here, but
            // to ensure a readable error message, we cut out the rest of the
            // processing
            return {};
        } else {
            const auto s = string_size_bound(std::forward<args_t>(args)...);
            std::string str_result;
            str_result.resize(s);  // reserve sufficient space for the output
            char *buf = str_result.data();
            char * buf_end = str_result.data() + s;

            parse_result.visit(
                [&buf, buf_end](auto &&arg) {
                    using placement::unsafe_place;
                    auto [bufr, ec] = unsafe_place(buf, buf_end, arg);
                    assert(ec == std::errc());
                    buf = bufr;
                },
                std::forward<args_t>(args)...);
            *buf = 0;
            str_result.resize(buf - str_result.data());
            return str_result;
        }
    }

    /**
     * Use the format definiton and the arguments to
     * create a formatted output and store it in the provided buffer.
     *
     * The buffer is expected to have at least a size of
     * string_size_bound(...) many bytes.
     */
    template <typename... args_t>
    std::optional<char*> format_to(char *buf, char * buf_end, args_t &&... args) const {
        constexpr bool parameter_count_match = pc == sizeof...(args);
        static_assert(
            parameter_count_match,
            "Number of format parameters doesn't match to format string");
        if constexpr (!parameter_count_match) {
            // we will already have static asserted when getting here, but
            // to ensure a readable error message, we cut out the rest of
            // the processing
            return {};
        } else {
            bool ok = true;
            constexpr auto placeable = placement::test_placements<args_t...>();
            if constexpr (!placeable) {
                // we will already have static asserted when getting here.
                return {};
            } else {
                parse_result.visit(
                    [&buf, buf_end, &ok](auto &&arg) {
                        using placement::unsafe_place;
                        auto [bufr, ec] = unsafe_place(buf, buf_end, arg);
                        ok &= ec == std::errc();
                        buf = bufr;
                    },
                    std::forward<args_t>(args)...);
                *buf = 0;
                if (!ok) {
                    return std::nullopt;
                }
                return {buf};
            }
        }
    }

    // return true if a format string is valid.
    // true for all log config objects returned by _fmt.
    constexpr bool ok() const noexcept { return valid; }
};  // namespace pformat

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-string-literal-operator-template"
#endif

namespace internal {
/*
 * Literal to crete a log config object. The validity of the log config
 * object is not statically or runtime checked, but can be validated with
 * ok().
 */
template <typename char_t, char_t... charpack>
constexpr auto operator""_unchecked_log() noexcept {
    static_assert(std::is_same<char_t, char>::value, "Only char is supported");
    constexpr auto parse_result = internal::parse_format<charpack...>();
    return log_config<decltype(parse_result),
                      parse_result.is_valid_format_string(),
                      parse_result.get_parameter_count()>(parse_result);
}

}  // namespace internal

/**
 * Literal to create log config object.
 *
 * It is statically asserted that the log config object is valid
 */
template <typename char_t, char_t... charpack>
constexpr auto operator""_log() noexcept {
    static_assert(std::is_same<char_t, char>::value, "Only char is supported");
    constexpr auto parse_result = internal::parse_format<charpack...>();
    static_assert(parse_result.is_valid_format_string(),
                  "Format string is not valid");
    return log_config<decltype(parse_result),
                      parse_result.is_valid_format_string(),
                      parse_result.get_parameter_count()>(parse_result);
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

}  // namespace pformat